<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D Physics Game - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #e0e5ec;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #333;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #e0e5ec;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 9px 9px 16px rgba(163, 177, 198, 0.6),
                -9px -9px 16px rgba(255, 255, 255, 0.5);
            z-index: 100;
            animation: slideRight 0.5s ease-out;
        }

        @keyframes slideRight {
            from {
                transform: translateX(-30px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 24px;
            color: #f59e0b;
            text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8),
                -2px -2px 4px rgba(163, 177, 198, 0.6);
        }

        .stat {
            margin: 8px 0;
            font-size: 14px;
            color: #666;
        }

        .stat strong {
            color: #f59e0b;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
            animation: fadeInUp 0.6s ease-out 0.3s both;
        }

        @keyframes fadeInUp {
            from {
                transform: translateX(-50%) translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        button {
            background: #e0e5ec;
            color: #f59e0b;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 6px 6px 12px rgba(163, 177, 198, 0.6),
                -6px -6px 12px rgba(255, 255, 255, 0.5);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(245, 158, 11, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 200px;
            height: 200px;
        }

        button:hover {
            box-shadow: inset 4px 4px 8px rgba(163, 177, 198, 0.6),
                inset -4px -4px 8px rgba(255, 255, 255, 0.5);
            transform: scale(0.98);
        }

        button:active {
            transform: scale(0.95);
        }

        .back-link {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            animation: slideLeft 0.5s ease-out;
        }

        @keyframes slideLeft {
            from {
                transform: translateX(30px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .back-link a {
            color: #666;
            text-decoration: none;
            font-size: 16px;
            padding: 10px 20px;
            border-radius: 10px;
            background: #e0e5ec;
            box-shadow: 6px 6px 12px rgba(163, 177, 198, 0.6),
                -6px -6px 12px rgba(255, 255, 255, 0.5);
            display: inline-block;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .back-link a:hover {
            box-shadow: inset 4px 4px 8px rgba(163, 177, 198, 0.6),
                inset -4px -4px 8px rgba(255, 255, 255, 0.5);
            transform: translateX(5px);
        }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="/3d-simulation/">← 3D物理シミュレーションに戻る</a>
    </div>

    <div id="info">
        <h1>Cannon.js Physics (JavaScript)</h1>
        <div class="stat"><strong>物理エンジン:</strong> Cannon.js (JavaScript製)</div>
        <div class="stat"><strong>描画エンジン:</strong> Three.js (WebGL)</div>
        <div class="stat"><strong>オブジェクト:</strong> <span id="object-count">0</span> 個</div>
        <div class="stat"><strong>FPS:</strong> <span id="fps">60</span></div>
        <div class="stat"><strong>操作:</strong> マウスドラッグで視点回転</div>
        <div class="stat"><strong>クリック:</strong> 周辺オブジェクトを爆発させる</div>
    </div>

    <div id="canvas-container"></div>

    <div id="controls">
        <button id="add-box">箱を追加</button>
        <button id="add-sphere">球を追加</button>
        <button id="add-many">大量追加 (50個)</button>
        <button id="add-stress">ストレステスト (500個)</button>
        <button id="reset">リセット</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        // シーン設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e5ec);
        scene.fog = new THREE.Fog(0xe0e5ec, 10, 50);

        // カメラ
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 5, 10);

        // レンダラー
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // コントロール
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // ライト
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // 物理世界
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        // 地面
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xa3b1c6,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // オブジェクト管理
        const objects = [];
        let objectCount = 0;

        // 箱を追加
        function addBox(x = 0, y = 5, z = 0) {
            const size = Math.random() * 0.5 + 0.5;
            const hue = Math.random() * 360;

            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(hue / 360, 0.7, 0.6),
                roughness: 0.7,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
            const body = new CANNON.Body({
                mass: 5,
                position: new CANNON.Vec3(x, y, z),
                shape: shape
            });
            world.addBody(body);

            objects.push({ mesh, body });
            objectCount++;
            updateObjectCount();
        }

        // 球を追加
        function addSphere(x = 0, y = 5, z = 0) {
            const radius = Math.random() * 0.3 + 0.3;
            const hue = Math.random() * 360;

            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(hue / 360, 0.7, 0.6),
                roughness: 0.5,
                metalness: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: 3,
                position: new CANNON.Vec3(x, y, z),
                shape: shape
            });
            world.addBody(body);

            objects.push({ mesh, body });
            objectCount++;
            updateObjectCount();
        }

        // 大量追加
        function addMany() {
            for (let i = 0; i < 50; i++) {
                const x = (Math.random() - 0.5) * 5;
                const y = 10 + i * 0.5;
                const z = (Math.random() - 0.5) * 5;

                if (Math.random() > 0.5) {
                    addBox(x, y, z);
                } else {
                    addSphere(x, y, z);
                }
            }
        }

        // ストレステスト
        function addStressTest() {
            for (let i = 0; i < 500; i++) {
                const x = (Math.random() - 0.5) * 8;
                const y = 15 + i * 0.3;
                const z = (Math.random() - 0.5) * 8;

                if (Math.random() > 0.5) {
                    addBox(x, y, z);
                } else {
                    addSphere(x, y, z);
                }
            }
        }

        // リセット
        function reset() {
            objects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            objects.length = 0;
            objectCount = 0;
            updateObjectCount();
        }

        function updateObjectCount() {
            document.getElementById('object-count').textContent = objectCount;
        }

        // イベントリスナー
        document.getElementById('add-box').addEventListener('click', () => {
            addBox(0, 5, 0);
        });

        document.getElementById('add-sphere').addEventListener('click', () => {
            addSphere(0, 5, 0);
        });

        document.getElementById('add-many').addEventListener('click', addMany);
        document.getElementById('add-stress').addEventListener('click', addStressTest);
        document.getElementById('reset').addEventListener('click', reset);

        // クリックで爆発エフェクト
        renderer.domElement.addEventListener('click', (event) => {
            if (event.target !== renderer.domElement) return;

            // マウス座標を3D座標に変換
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // レイキャスト
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);

            // 地面との交点を計算
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                explode(point.x, point.y, point.z);
            }
        });

        // 視覚エフェクト管理
        const explosionEffects = [];

        // 爆発効果
        function explode(clickX, clickY, clickZ) {
            const explosionForce = 500.0;
            const explosionRadius = 5.0;

            // 視覚エフェクト追加
            createExplosionEffect(clickX, clickY, clickZ);

            objects.forEach(obj => {
                const pos = obj.body.position;
                const dx = pos.x - clickX;
                const dy = pos.y - clickY;
                const dz = pos.z - clickZ;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < explosionRadius) {
                    const force = explosionForce * (1.0 - dist / explosionRadius);
                    const dirX = dx / (dist + 0.001);
                    const dirY = dy / (dist + 0.001);
                    const dirZ = dz / (dist + 0.001);

                    obj.body.applyImpulse(
                        new CANNON.Vec3(dirX * force, dirY * force, dirZ * force),
                        obj.body.position
                    );
                }
            });
        }

        // 爆発エフェクト生成
        function createExplosionEffect(x, y, z) {
            // 外側のリング
            const ringGeometry1 = new THREE.RingGeometry(0.1, 0.3, 32);
            const ringMaterial1 = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0
            });
            const ring1 = new THREE.Mesh(ringGeometry1, ringMaterial1);
            ring1.position.set(x, y + 0.05, z);
            ring1.rotation.x = -Math.PI / 2;
            scene.add(ring1);

            // 内側のリング
            const ringGeometry2 = new THREE.RingGeometry(0.05, 0.15, 32);
            const ringMaterial2 = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0
            });
            const ring2 = new THREE.Mesh(ringGeometry2, ringMaterial2);
            ring2.position.set(x, y + 0.06, z);
            ring2.rotation.x = -Math.PI / 2;
            scene.add(ring2);

            // 中心の光球
            const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(x, y + 0.3, z);
            scene.add(sphere);

            explosionEffects.push({
                rings: [ring1, ring2],
                sphere: sphere,
                time: 0,
                maxTime: 1.0
            });
        }

        // エフェクト更新
        function updateExplosionEffects(delta) {
            for (let i = explosionEffects.length - 1; i >= 0; i--) {
                const effect = explosionEffects[i];
                effect.time += delta;

                const progress = effect.time / effect.maxTime;

                if (progress >= 1.0) {
                    // エフェクト削除
                    effect.rings.forEach(ring => scene.remove(ring));
                    scene.remove(effect.sphere);
                    explosionEffects.splice(i, 1);
                } else {
                    // リングを拡大
                    const scale = 1.0 + progress * 15.0;
                    effect.rings.forEach(ring => {
                        ring.scale.set(scale, scale, 1);
                        ring.material.opacity = 1.0 - progress;
                    });

                    // 光球を縮小・フェードアウト
                    const sphereScale = 1.0 - progress * 0.7;
                    effect.sphere.scale.set(sphereScale, sphereScale, sphereScale);
                    effect.sphere.material.opacity = 1.0 - progress;
                }
            }
        }

        // FPS計算
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            // 物理シミュレーション
            world.step(1 / 60);

            // オブジェクトの位置を同期
            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            // エフェクト更新
            updateExplosionEffects(1 / 60);

            // コントロール更新
            controls.update();

            // FPS計算
            frameCount++;
            const now = performance.now();
            if (frameCount % 60 === 0) {
                fps = Math.round(1000 / (now - lastTime));
                document.getElementById('fps').textContent = fps;
            }
            lastTime = now;

            // レンダリング
            renderer.render(scene, camera);
        }

        // リサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初期オブジェクト
        addBox();
        addSphere();

        // 開始
        animate();
    </script>
</body>
</html>
